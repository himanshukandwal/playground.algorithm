package dev.research.himanshu.algorithm.dynamicprogramming;

/**
 * Given a triangle, find the minimum path sum from top to bottom. 
 * Each step you may move to adjacent numbers on the row below.
 * For example, given the following triangle
 * 
 * [
 *      [2],
 *     [3,4],
 *    [6,5,7],
 *   [4,1,8,3]
 * ]
 *
 * @author Himanshu Kandwal
 *
 */
public class MinPathTriangleArrayStack {
	
	private int[] inputSequence;
	
	public MinPathTriangleArrayStack() {}

	public MinPathTriangleArrayStack(int[] inputSequence) {
		this.inputSequence = inputSequence;
	}
	
	public void setInputSequence(int[] inputSequence) {
		this.inputSequence = inputSequence;
	}
	
	public int[] getInputSequence() {
		return inputSequence;
	}
	
	public Integer getMaxFrequency() {
		if (getInputSequence() == null || getInputSequence().length == 0) {
			System.out.println(" No data present in input sequence !");
			return null;
		}
		
		int maxCount, runningCount, topNumber;
		int[][] maxFreqArr = new int[10][10];
		topNumber = getInputSequence()[0];
		maxCount = -1;
		
		for (int index = 1; index < getInputSequence().length; index ++) {
			int currentNumber = getInputSequence() [index];
			
			if (currentNumber == topNumber) {
				runningCount ++;
			}
			
			if (maxCount < runningCount) {
				maxCount = runningCount;
				topNumber = currentNumber;
			} 
		}
		
		System.out.println(" Max count : " + maxCount + " , topNumber : " + topNumber);
		return maxCount;
	}
	
}
